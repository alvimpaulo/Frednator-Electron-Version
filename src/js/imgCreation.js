const videoUtil = require("../../build/Release/videoUtil");

//$start imgCreation.js:requires$

//$start imgCreation.js:requires:yellowDetector$
const yellowDetectorUtil = require("../../build/Release/yellowDetectorUtil");
//$end imgCreation.js:requires:yellowDetector$

//$start imgCreation.js:requires:lineDetector$
const lineDetectorUtil = require("../../build/Release/lineDetectorUtil");
//$end imgCreation.js:requires:lineDetector$

//$start imgCreation.js:requires:fieldDetector2$
const fieldDetector2Util = require("../../build/Release/fieldDetector2Util");
//$end imgCreation.js:requires:fieldDetector2$

//$end imgCreation.js:requires$

let cap; //capture

/**
 * Function to open a capture.
 *
 * @param {*} path Capture address.
 * @returns External that will be a cv::VideoCapture.
 */
function openCap(path) {
  let capIndex = parseInt(path);
  if (!isNaN(capIndex)) {
    //if path is a number, use parsed number
    return videoUtil.videoOpener(capIndex);
  } else {
    //If path is a file path, use the path itself
    return videoUtil.videoOpener(path);
  }
}

/**
 * Function to close a cv::VideoCapture.
 *
 * @param {*} capToClose cv::VideoCapture to close.
 */
function closeCap(capToClose) {
  let closingResponse = videoUtil.videoCloser(capToClose);
  if (closingResponse == false) {
    console.log("couldn't close cap");
  } else if (closingResponse == true) {
    console.log("closed cap");
    cap = false;
  }
}

/**
 * Async function to create an ImageBitmap.
 *
 * @param {number} [captureParam=0] cv::videoCapture parameter.
 * @param {number} [debugImageVectorIndex=0] debugImageVector image to return.
 * @param {*} classSelected String containing Spaced Detector.
 * @returns ImageData containing the selected image from debugImageVector.
 */
function createMyImageBitmap(
  captureParam = 0,
  debugImageVectorIndex = 0,
  classSelected
) {
  return new Promise((resolve, reject) => {
    let imgBitmap;
    if (!cap) cap = openCap(captureParam); // if capture isn't already open
    if (typeof cap === "boolean") {
      // if it was returned false
      reject("capture is boolean");
      return;
    }

    let img = videoUtil.imgFromVideo(cap);
    if (typeof img === "boolean") {
      cap = false;
      reject("Img is boolean");
      return;
    }

    /**
     * Execute run function from the detector.
     *
     * @param {*} util Detector Util.
     */
    function runDetector(util) {
      img = util.run(
        img,
        util.detector,
        util.perceptionData,
        parseInt(debugImageVectorIndex)
      );
    }

    //! Start of code used and generated by an external program, be careful when changing it

    //$start imgCreation.js:createMyImageBitmap$

    //$start imgCreation.js:createMyImageBitmap:yellowDetector$
    if (classSelected === "Yellow Detector") {
      runDetector(yellowDetectorUtil);
    }
    //$end imgCreation.js:createMyImageBitmap:yellowDetector$

    //$start imgCreation.js:createMyImageBitmap:lineDetector$
    if (classSelected === "Line Detector") {
      runDetector(lineDetectorUtil);
    }
    //$end imgCreation.js:createMyImageBitmap:lineDetector$

    //$start imgCreation.js:createMyImageBitmap:fieldDetector2$
    if (classSelected === "Field Detector2") {
      runDetector(fieldDetector2Util);
    }
    //$end imgCreation.js:createMyImageBitmap:fieldDetector2$

    //$end imgCreation.js:createMyImageBitmap$

    //! End of code used and generated by an external program, be careful when changing it
    let newimgarray = videoUtil.typedArrayFromCvMat(img);

    let imageDataFromArray = new ImageData(
      new Uint8ClampedArray(newimgarray),
      640
    );

    createImageBitmap(imageDataFromArray).then(imgBitmapCreated => {
      resolve(imgBitmapCreated);
    });
    newimgarray = null;
  });
}
